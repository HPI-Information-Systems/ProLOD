/*-
 * Copyright 2012 by: Hasso Plattner Institute for Software Systems Engineering 
 * Prof.-Dr.-Helmert-Str. 2-3
 * 14482 Potsdam, Germany
 * Potsdam District Court, HRB 12184
 * Authorized Representative Managing Director: Prof. Dr. Christoph Meinel
 * http://www.hpi-web.de/
 * 
 * Information Systems Group, http://www.hpi-web.de/naumann/
 * 
 * 
 * Licence: http://creativecommons.org/licenses/by-sa/3.0/
 * 
 */

package de.hpi.fgis.ldp.server.algorithms.labeling;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * A rewriter does a global substitution in the strings passed to its 'rewrite' method. It uses the
 * pattern supplied to its constructor, and is like 'String.replaceAll' except for the fact that its
 * replacement strings are generated by invoking a method you write, rather than from another
 * string.
 * 
 * This class is supposed to be equivalent to Ruby's 'gsub' when given a block. This is the nicest
 * syntax I've managed to come up with in Java so far. It's not too bad, and might actually be
 * preferable if you want to do the same rewriting to a number of strings in the same method or
 * class.
 * 
 * See the example 'main' for a sample of how to use this class.
 * 
 * @author Elliott Hughes
 * @author Roger Millington
 */

abstract class Rewriter {
  private final Pattern pattern;
  private Matcher matcher;

  /**
   * Constructs a rewriter using the given regular expression; the syntax is the same as for
   * 'Pattern.compile'.
   */
  public Rewriter(String regularExpression) {
    this.pattern = Pattern.compile(regularExpression);
  }

  /**
   * Returns the input subsequence captured by the given group during the previous match operation.
   */
  public String group(int i) {
    return this.matcher.group(i);
  }

  /**
   * Overridden to compute a replacement for each match. Use the method 'group' to access the
   * captured groups.
   */
  public abstract String replacement();

  /**
   * Returns the result of rewriting 'original' by invoking the method 'replacement' for each match
   * of the regular expression supplied to the constructor.
   */
  public String rewrite(CharSequence original) {
    return this.rewrite(original, new StringBuffer(original.length())).toString();
  }

  /**
   * Returns the result of appending the rewritten 'original' to 'destination'. We have to use
   * StringBuffer rather than the more obvious and general Appendable because of Matcher's interface
   * (Sun bug 5066679). Most users will prefer the single-argument rewrite, which supplies a
   * temporary StringBuffer itself.
   */
  public StringBuffer rewrite(CharSequence original, StringBuffer destination) {
    this.matcher = this.pattern.matcher(original);
    while (this.matcher.find()) {
      this.matcher.appendReplacement(destination, "");
      destination.append(this.replacement());
    }
    this.matcher.appendTail(destination);
    return destination;
  }

}


public class UnicodeRewriter extends Rewriter {
  public UnicodeRewriter() {
    super("\\\\u([0-9a-fA-F]{4})");
  }

  @Override
  public String replacement() {
    return Character.toString((char) Integer.parseInt(this.group(1), 16));
  }
}
